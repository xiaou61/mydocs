const e=JSON.parse('{"key":"v-19995b2d","path":"/interview/selected/10.html","title":"Java 并发编程八股文（背诵版）必看","lang":"zh-CN","frontmatter":{"title":"Java 并发编程八股文（背诵版）必看","icon":"community","category":["面试"],"tag":["面试"],"sticky":false,"star":true,"article":true,"timeline":true,"description":"简述Java内存模型（JMM） Java内存模型定义了程序中各种变量的访问规则： 所有变量都存储在主存，每个线程都有自己的工作内存。; 工作内存中保存了被该线程使用的变量的主存副本，线程对变量的所有操作都必须在工作空间进行，不能直接读写主内存数据。; 操作完成后，线程的工作内存通过缓存一致性协议将操作完的数据刷回主存。; 简述as-if-serial ...","head":[["meta",{"property":"og:url","content":"https://mydocs.guoyaxue.top/interview/selected/10.html"}],["meta",{"property":"og:site_name","content":"小uの学习笔记"}],["meta",{"property":"og:title","content":"Java 并发编程八股文（背诵版）必看"}],["meta",{"property":"og:description","content":"简述Java内存模型（JMM） Java内存模型定义了程序中各种变量的访问规则： 所有变量都存储在主存，每个线程都有自己的工作内存。; 工作内存中保存了被该线程使用的变量的主存副本，线程对变量的所有操作都必须在工作空间进行，不能直接读写主内存数据。; 操作完成后，线程的工作内存通过缓存一致性协议将操作完的数据刷回主存。; 简述as-if-serial ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-08-08T04:27:39.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:modified_time","content":"2023-08-08T04:27:39.000Z"}]]},"excerpt":"","headers":[{"level":3,"title":"简述Java内存模型（JMM）","slug":"简述java内存模型-jmm","link":"#简述java内存模型-jmm","children":[]},{"level":3,"title":"简述as-if-serial","slug":"简述as-if-serial","link":"#简述as-if-serial","children":[]},{"level":3,"title":"简述happens-before八大规则","slug":"简述happens-before八大规则","link":"#简述happens-before八大规则","children":[]},{"level":3,"title":"as-if-serial 和 happens-before 的区别","slug":"as-if-serial-和-happens-before-的区别","link":"#as-if-serial-和-happens-before-的区别","children":[]},{"level":3,"title":"简述原子性操作","slug":"简述原子性操作","link":"#简述原子性操作","children":[]},{"level":3,"title":"简述线程的可见性","slug":"简述线程的可见性","link":"#简述线程的可见性","children":[]},{"level":3,"title":"简述有序性","slug":"简述有序性","link":"#简述有序性","children":[]},{"level":3,"title":"简述Java中volatile关键字作用","slug":"简述java中volatile关键字作用","link":"#简述java中volatile关键字作用","children":[]},{"level":3,"title":"Java线程的实现方式","slug":"java线程的实现方式","link":"#java线程的实现方式","children":[]},{"level":3,"title":"简述Java线程的状态","slug":"简述java线程的状态","link":"#简述java线程的状态","children":[]},{"level":3,"title":"简述线程通信的方式","slug":"简述线程通信的方式","link":"#简述线程通信的方式","children":[]},{"level":3,"title":"简述线程池","slug":"简述线程池","link":"#简述线程池","children":[]},{"level":3,"title":"简述Executor框架","slug":"简述executor框架","link":"#简述executor框架","children":[]},{"level":3,"title":"简述Executor的继承关系","slug":"简述executor的继承关系","link":"#简述executor的继承关系","children":[]},{"level":3,"title":"简述线程池的状态","slug":"简述线程池的状态","link":"#简述线程池的状态","children":[]},{"level":3,"title":"简述线程池类型","slug":"简述线程池类型","link":"#简述线程池类型","children":[]},{"level":3,"title":"简述阻塞队列","slug":"简述阻塞队列","link":"#简述阻塞队列","children":[]},{"level":3,"title":"谈一谈ThreadLocal","slug":"谈一谈threadlocal","link":"#谈一谈threadlocal","children":[]},{"level":3,"title":"聊聊你对Java并发包下unsafe类的理解","slug":"聊聊你对java并发包下unsafe类的理解","link":"#聊聊你对java并发包下unsafe类的理解","children":[]},{"level":3,"title":"Java中的乐观锁与CAS算法","slug":"java中的乐观锁与cas算法","link":"#java中的乐观锁与cas算法","children":[]},{"level":3,"title":"ABA问题及解决方法简述","slug":"aba问题及解决方法简述","link":"#aba问题及解决方法简述","children":[]},{"level":3,"title":"简述常见的Atomic类","slug":"简述常见的atomic类","link":"#简述常见的atomic类","children":[]},{"level":3,"title":"简述Atomic类基本实现原理","slug":"简述atomic类基本实现原理","link":"#简述atomic类基本实现原理","children":[]},{"level":3,"title":"简述CountDownLatch","slug":"简述countdownlatch","link":"#简述countdownlatch","children":[]},{"level":3,"title":"简述CyclicBarrier","slug":"简述cyclicbarrier","link":"#简述cyclicbarrier","children":[]},{"level":3,"title":"简述Semaphore","slug":"简述semaphore","link":"#简述semaphore","children":[]},{"level":3,"title":"简述Exchanger","slug":"简述exchanger","link":"#简述exchanger","children":[]},{"level":3,"title":"简述ConcurrentHashMap","slug":"简述concurrenthashmap","link":"#简述concurrenthashmap","children":[]},{"level":3,"title":"synchronized底层实现原理","slug":"synchronized底层实现原理","link":"#synchronized底层实现原理","children":[]},{"level":3,"title":"synchronized关键词使用方法","slug":"synchronized关键词使用方法","link":"#synchronized关键词使用方法","children":[]},{"level":3,"title":"简述Java偏向锁","slug":"简述java偏向锁","link":"#简述java偏向锁","children":[]},{"level":3,"title":"简述轻量级锁","slug":"简述轻量级锁","link":"#简述轻量级锁","children":[]},{"level":3,"title":"简述锁优化策略","slug":"简述锁优化策略","link":"#简述锁优化策略","children":[]},{"level":3,"title":"简述Java的自旋锁","slug":"简述java的自旋锁","link":"#简述java的自旋锁","children":[]},{"level":3,"title":"简述自适应自旋锁","slug":"简述自适应自旋锁","link":"#简述自适应自旋锁","children":[]},{"level":3,"title":"简述锁粗化","slug":"简述锁粗化","link":"#简述锁粗化","children":[]},{"level":3,"title":"简述锁消除","slug":"简述锁消除","link":"#简述锁消除","children":[]},{"level":3,"title":"简述Lock与ReentrantLock","slug":"简述lock与reentrantlock","link":"#简述lock与reentrantlock","children":[]},{"level":3,"title":"简述AQS","slug":"简述aqs","link":"#简述aqs","children":[]}],"git":{"createdTime":1691468859000,"updatedTime":1691468859000,"contributors":[{"name":"Lenovo","email":"3153566913@qq.com","commits":1}]},"readingTime":{"minutes":18.81,"words":5643},"filePathRelative":"interview/selected/10.md","localizedDate":"2023年8月8日"}');export{e as data};
